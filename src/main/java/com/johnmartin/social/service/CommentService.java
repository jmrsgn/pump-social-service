package com.johnmartin.social.service;

import java.util.List;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import com.johnmartin.social.constants.UIConstants;
import com.johnmartin.social.constants.api.ApiErrorMessages;
import com.johnmartin.social.dto.AuthUser;
import com.johnmartin.social.dto.request.CreateCommentRequest;
import com.johnmartin.social.dto.response.CommentResponse;
import com.johnmartin.social.entities.CommentEntity;
import com.johnmartin.social.entities.PostEntity;
import com.johnmartin.social.exception.BadRequestException;
import com.johnmartin.social.exception.ResourceNotFoundException;
import com.johnmartin.social.exception.UnauthorizedException;
import com.johnmartin.social.mapper.CommentMapper;
import com.johnmartin.social.repository.CommentRepository;
import com.johnmartin.social.security.AuthContext;
import com.johnmartin.social.utilities.LoggerUtility;

import jakarta.transaction.Transactional;

@Service
public class CommentService {

    private static final Class<CommentService> clazz = CommentService.class;

    @Autowired
    private CommentRepository commentRepository;

    @Autowired
    private PostService postService;

    /**
     * Get comments
     * 
     * @param postId
     *            - Post ID
     * @param page
     *            - page
     * @return List of CommentResponse
     */
    public List<CommentResponse> getComments(String postId, String userId, int page) {
        PageRequest pageRequest = PageRequest.of(page, UIConstants.MINIMUM_COMMENTS_PER_POST);
        List<CommentEntity> commentEntityList = commentRepository.findByPostIdOrderByCreatedAtDesc(postId, pageRequest);
        return commentEntityList.stream().map(comment -> CommentMapper.toResponse(comment, userId)).toList();
    }

    /**
     * Create a comment
     *
     * @param postId
     *            - Post ID
     * @param request
     *            - CreateCommentRequest
     * @return CommentResponse
     */
    public CommentResponse createComment(String postId, CreateCommentRequest request) {
        LoggerUtility.d(clazz,
                        String.format("Execute method: [createComment] postId: [%s] request: [%s]", postId, request));

        if (StringUtils.isBlank(postId) || request == null) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        AuthUser authUser = AuthContext.get();
        PostEntity post = postService.getPostById(postId);

        CommentEntity createdComment = new CommentEntity();
        createdComment.setComment(request.getComment());
        createdComment.setAuthorId(authUser.getId());
        createdComment.setPostId(post.getId());
        createdComment.setAuthor(authUser.getFirstName() + " " + authUser.getLastName());
        createdComment.setAuthorProfileImageUrl(authUser.getProfileImageUrl());
        createdComment.setLikesCount(0);
        createdComment.setRepliesCount(0);

        // ID and Dates are generated by MongoDB after insertion
        CommentEntity commentToBeReturned = saveComment(createdComment);
        LoggerUtility.t(clazz, String.format("commentToBeReturned: [%s]", commentToBeReturned));
        return CommentMapper.toResponse(commentToBeReturned, authUser.getId());
    }

    /**
     * Delete a comment
     *
     * @param commentId
     *            - Comment ID
     */
    public void deleteComment(String postId, String commentId) {
        LoggerUtility.d(clazz,
                        String.format("Execute method: [deleteComment] postId: [%s] commentId: [%s]",
                                      postId,
                                      commentId));

        if (StringUtils.isBlank(postId)) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        if (StringUtils.isBlank(commentId)) {
            throw new BadRequestException(ApiErrorMessages.Comment.COMMENT_ID_IS_REQUIRED);
        }

        AuthUser authUser = AuthContext.get();
        PostEntity post = postService.getPostById(postId);
        CommentEntity comment = getCommentById(commentId);

        // Ensure comment belongs to the post
        if (!comment.getPostId().equals(post.getId())) {
            throw new BadRequestException(ApiErrorMessages.Comment.THE_COMMENT_DOES_NOT_BELONG_TO_THE_SPECIFIED_POST);
        }

        // Only comment owner can delete
        if (!comment.getAuthorId().equals(authUser.getId())) {
            throw new UnauthorizedException(ApiErrorMessages.User.YOU_ARE_NOT_AUTHORIZED_TO_PERFORM_THIS_ACTION);
        }

        // Delete comment
        commentRepository.deleteById(comment.getId());

        // Decrement post comment count
        postService.decrementCommentsCount(post.getId());
    }

    /**
     * Save a comment then increment post's comments count
     * 
     * @param comment
     *            - Comment
     * @return CommentEntity
     */
    @Transactional
    public CommentEntity saveComment(CommentEntity comment) {
        CommentEntity savedComment = commentRepository.save(comment);
        postService.incrementCommentsCount(comment.getPostId());
        return savedComment;
    }

    /**
     * Like a comment
     *
     * @param postId
     *            - Post ID
     *
     * @param commentId
     *            - Comment ID
     * @return CommentResponse
     */
    public CommentResponse likeComment(String postId, String commentId) {
        LoggerUtility.d(clazz,
                        String.format("Execute method: [likeComment] postId: [%s] commentId: [%s]", postId, commentId));

        if (StringUtils.isBlank(postId)) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        if (StringUtils.isBlank(commentId)) {
            throw new BadRequestException(ApiErrorMessages.Comment.COMMENT_ID_IS_REQUIRED);
        }

        AuthUser authUser = AuthContext.get();
        CommentEntity comment = getCommentById(commentId);

        // If user already liked the comment, unlike
        if (CollectionUtils.containsAny(comment.getLikedByUserIds(), authUser.getId())) {
            applyUnlikeComment(authUser.getId(), comment.getId());
        } else {
            applyLikeComment(authUser.getId(), comment.getId());
        }

        // Get updated post to get updated like state
        CommentEntity updatedComment = getCommentById(comment.getId());
        LoggerUtility.t(clazz, String.format("updatedComment: [%s]", updatedComment));
        return CommentMapper.toResponse(updatedComment, authUser.getId());
    }

    /**
     * Delete all comments from a Post
     * 
     * @param postId
     *            - Post ID
     */
    public void deleteByPostId(String postId) {
        PostEntity post = postService.getPostById(postId);
        commentRepository.deleteByPostId(post.getId());
    }

    /**
     * Get comment by ID
     *
     * @param commentId
     *            - Comment ID
     * @return CommentEntity
     */
    private CommentEntity getCommentById(String commentId) {
        return commentRepository.findById(commentId)
                                .orElseThrow(() -> new ResourceNotFoundException(ApiErrorMessages.Comment.COMMENT_NOT_FOUND));
    }

    /**
     * Like a comment
     * 
     * @param userId
     *            - User ID
     * @param commentId
     *            - Comment ID
     */
    public void applyLikeComment(String userId, String commentId) {
        commentRepository.likeComment(userId, commentId);
    }

    /**
     * Unlike a comment
     * 
     * @param userId
     *            - User ID
     * @param commentId
     *            - Comment ID
     */
    public void applyUnlikeComment(String userId, String commentId) {
        commentRepository.unlikeComment(userId, commentId);
    }
}
